.. _generated_cpp_libs:

Generated C++ Libraries
-----------------------

A C++ Library to numerically compute a given integral/ loop integral can be generated by the :func:`~pySecDec.code_writer.sum_package`, :func:`~pySecDec.make_package`and :func:`~pySecDec.loop_integral.loop_package` functions.
The `name` passed to the :func:`~pySecDec.make_package` or :func:`~pySecDec.loop_integral.loop_package` function will be used as the C++ namespace of the generated library.
A program demonstrating the use of the C++ library is generated for each integral and written to ``name/integrate_name.cpp``. Here we document the C++ library API.

.. seealso::

    :ref:`C++ Interface <intlib_cpp>`

.. _generated_cpp_amplitude_sum_libs:

Amplitude/Sum libraries
~~~~~~~~~~~~~~~~~~~~~~~

.. versionadded:: 1.5

Generated by  :func:`~pySecDec.code_writer.sum_package` in the folder ``name``.

.. cpp:namespace:: name

.. cpp:var:: const unsigned long long number_of_integrals

    The number of integrals in the library.

.. cpp:var:: const unsigned int number_of_amplitudes

    The number of amplitudes in the library.

.. cpp:var:: const unsigned int number_of_real_parameters

    The number of real parameters on which the integral depends.

.. cpp:var:: const std::vector<std::string> names_of_real_parameters

    An ordered vector of string representations of the names of the real parameters.

.. cpp:var:: const unsigned int number_of_complex_parameters

    The number of complex parameters on which the integral depends.

.. cpp:var:: const std::vector<std::string> names_of_complex_parameters

    An ordered vector of string representations of the names of the complex parameters.

.. cpp:var:: const unsigned int number_of_regulators

    The number of regulators on which the integral depends.

.. cpp:var:: const std::vector<std::string> names_of_regulators

    A vector of the names of the regulators.

.. cpp:var:: const std::vector<int> requested_orders

    A vector of the requested orders of each regulator used to generate the C++ library, i.e. the `requested_orders` parameter passed to :func:`~pySecDec.make_package`, :func:`~pySecDec.loop_integral.loop_package` or :func:`~pySecDec.code_writer.sum_package`.

.. cpp:type:: double real_t

    The real type used by the library.

.. cpp:type:: std::complex<real_t> complex_t

    The complex type used by the library.

    const unsigned int maximal_number_of_integration_variables = 2;

.. cpp:type:: integrand_return_t

    The return type of the integrand function.
    If the integral has complex parameters or uses contour deformation or if `enforce_complex` is set to ``True`` in the call to :func:`~pySecDec.code_writer.make_package` or :func:`~pySecDec.loop_integral.loop_package` then `integrand_return_t` is `complex_t`. Otherwise `integrand_return_t` is `real_t`.

.. cpp:type:: template<typename T> nested_series_t = secdecutil::Series<secdecutil::Series<...<T>>>

    A potentially nested :cpp:class:`secdecutil::Series` representing the series expansion in each of the regulators.
    If the integral depends on only one regulator (for example, a loop integral generated with :func:`~pySecDec.loop_integral.loop_package`) this type will be a :cpp:class:`secdecutil::Series`.
    For integrals that depend on multiple regulators then this will be a series of series representing the multivariate series.
    This type can be used to write code that can handle integrals depending on arbitrarily many regulators.

    .. seealso::

        :cpp:class:`secdecutil::Series`


.. cpp:type:: template<typename T> using amplitudes_t = std::vector<nested_series_t<T>>

    A vector of nested :cpp:class:`secdecutil::Series` representing the amplitudes.
 
.. cpp:type:: typedef secdecutil::IntegrandContainer<integrand_return_t, real_t const * const, real_t> integrand_t

    The type of the integrands. Within the generated C++ library integrands are stored in a container along with the number of integration variables upon which they depend. These containers can be passed to an integrator for numerical integration.

.. cpp:type:: cuda_integrand_t

    The type of a single integrand (sector) usable on a CUDA device (GPU). This container can be passed to an integrator for numerical integration.

    .. seealso::

        :cpp:class:`secdecutil::IntegrandContainer`, :cpp:class:`secdecutil::Integrator`, and :cpp:class:`secdecutil::integrators::Qmc`.

.. cpp:type:: typedef integrand_t user_integrand_t

    A convenience type of referring to either an `integrand_t` or `cuda_integrand_t` if the library was built with a CUDA compatible compiler.

.. cpp:type:: typedef secdecutil::amplitude::Integral<integrand_return_t,real_t> integral_t

    The type of the amplitude integral wrapper.

    .. warning::

        The precise definition and usage of :cpp:class:`secdecutil::amplitude::Integral` is likely to change in future versions of `pySecDec`.

.. cpp:type:: typedef secdecutil::amplitude::WeightedIntegral<integral_t,integrand_return_t> weighted_integral_t

    The type of the weighted integral. Weighted integrals consist of an integral, `I`, and the coefficient of the integral, `C`. 
    A :ref:`WeightedIntegral <chapter_secdecutil_weighted_integral>` is interpreted as the product `C*I` and can be used to represent individual terms in an amplitude.

.. cpp:type:: typedef std::vector<weighted_integral_t> sum_t

    The type of a sum of weighted integrals.

.. cpp:type:: template<template<typename...> class container_t> using handler_t = secdecutil::amplitude::WeightedIntegralHandler<integrand_return_t,real_t,integrand_return_t,container_t>

    The type of the weighted integral handler. A :ref:`WeightedIntegralHandler <chapter_secdecutil_weighted_integral_handler>` defines an algorithm for evaluating a sum of weighted integrals.

.. cpp:function:: std::vector<nested_series_t<sum_t>> make_amplitudes(const std::vector<real_t>& real_parameters, const std::vector<complex_t>& complex_parameters, const std::string& lib_path, const integrator_t& integrator)

    `(without contour deformation)`

.. cpp:function:: std::vector<nested_series_t<sum_t>> make_amplitudes(const std::vector<real_t>& real_parameters, const std::vector<complex_t>& complex_parameters, const std::string& lib_path, const integrator_t& integrator, unsigned number_of_presamples = 100000, real_t deformation_parameters_maximum = 1., real_t deformation_parameters_minimum = 1.e-5, real_t deformation_parameters_decrease_factor = 0.9)

    `(with contour deformation)`

    Constructs and returns a vector of amplitudes ready to be passed to a :ref:`WeightedIntegralHandler <chapter_secdecutil_weighted_integral_handler>` for evaluation.
    Each element of the vector contains an amplitude (weighted sum of integrals).
    The real and complex parameters are bound to the values passed in `real_parameters` and `complex_parameters`.
    The `lib_path` parameter is used to specify the path to the coefficients and individual integral libraries.
    The `integrator` parameter is used to specify which integrator should be used to evaluate the integrals.
    If enabled, contour deformation is controlled by the parameters `number_of_presamples`, `deformation_parameters_maximum`, `deformation_parameters_minimum`, `deformation_parameters_decrease_factor`
    which are documented in :class:`pySecDec.integral_interface.IntegralLibrary`.

.. _generated_cpp_integral_libs:

Integral libraries
~~~~~~~~~~~~~~~~~~

Generated by :func:`~pySecDec.code_writer.make_package` in the folder ``name`` or by :func:`~pySecDec.code_writer.sum_package` in the folder ``name/name_integral``.

.. cpp:namespace:: name

.. cpp:type:: double real_t

    The real type used by the library.

.. cpp:type:: std::complex<real_t> complex_t

    The complex type used by the library.

.. cpp:type:: integrand_return_t

    The return type of the integrand function.
    If the integral has complex parameters or uses contour deformation or if `enforce_complex` is set to ``True`` in the call to :func:`~pySecDec.code_writer.make_package` or :func:`~pySecDec.loop_integral.loop_package` then `integrand_return_t` is `complex_t`. Otherwise `integrand_return_t` is `real_t`.

.. cpp:type:: template<typename T> nested_series_t = secdecutil::Series<secdecutil::Series<...<T>>>

    A potentially nested :cpp:class:`secdecutil::Series` representing the series expansion in each of the regulators.
    If the integral depends on only one regulator (for example, a loop integral generated with :func:`~pySecDec.loop_integral.loop_package`) this type will be a :cpp:class:`secdecutil::Series`.
    For integrals that depend on multiple regulators then this will be a series of series representing the multivariate series.
    This type can be used to write code that can handle integrals depending on arbitrarily many regulators.

    .. seealso::

        :cpp:class:`secdecutil::Series`

.. cpp:type:: secdecutil::IntegrandContainer<integrand_return_t, real_t const * const> integrand_t

    The type of the integrand. Within the generated C++ library integrands are stored in a container along with the number of integration variables upon which they depend. These containers can be passed to an integrator for numerical integration.

    .. seealso::

        :cpp:class:`secdecutil::IntegrandContainer` and :cpp:class:`secdecutil::Integrator`.

.. cpp:type:: cuda_integrand_t

    .. versionadded:: 1.4

    The type of a single integrand (sector) usable on a CUDA device (GPU). This container can be passed to an integrator for numerical integration.

    .. seealso::

        :cpp:class:`secdecutil::IntegrandContainer`, :cpp:class:`secdecutil::Integrator`, and :cpp:class:`secdecutil::integrators::Qmc`.

.. cpp:type:: cuda_together_integrand_t

    .. versionadded:: 1.4

    The type of a sum of integrands (sectors) usable on a CUDA device (GPU). This container can be passed to an integrator for numerical integration.

    .. seealso::

        :cpp:class:`secdecutil::IntegrandContainer`, :cpp:class:`secdecutil::Integrator`, and :cpp:class:`secdecutil::integrators::Qmc`.

.. cpp:var:: const unsigned long long number_of_sectors

    The number of sectors generated by the sector decomposition.

    .. versionchanged:: 1.3.1
        Type was :cpp:expr:`unsigned int` in earlier versions of `pySecDec`.


.. cpp:var:: const unsigned int maximal_number_of_integration_variables

    The number of integration variables after primary decomposition. This provides an upper bound in the
    number of integration variables for all integrand functions. The actual number of integration variables
    may be lower for a given integrand.

.. cpp:var:: const unsigned int number_of_regulators

    The number of regulators on which the integral depends.

.. cpp:var:: const unsigned int number_of_real_parameters

    The number of real parameters on which the integral depends.

.. cpp:var:: const std::vector<std::string> names_of_real_parameters

    An ordered vector of string representations of the names of the real parameters.

.. cpp:var:: const unsigned int number_of_complex_parameters

    The number of complex parameters on which the integral depends.

.. cpp:var:: const std::vector<std::string> names_of_complex_parameters

    An ordered vector of string representations of the names of the complex parameters.

.. cpp:var:: const std::vector<int> lowest_orders

    A vector of the lowest order of each regulator which appears in the integral, not including the prefactor.

.. cpp:var:: const std::vector<int> highest_orders

    A vector of the highest order of each regulator which appears in the integral, not including the prefactor.
    This depends on the `requested_orders` and `prefactor`/`additional_prefactor` parameter passed to :func:`~pySecDec.code_writer.make_package` or :func:`~pySecDec.loop_integral.loop_package`.
    In the case of :func:`~pySecDec.loop_integral.loop_package` it also depends on the :math:`\Gamma`-function prefactor of the integral which appears upon Feynman parametrization.

.. cpp:var:: const std::vector<int> lowest_prefactor_orders

    A vector of the lowest order of each regulator which appears in the prefactor of the integral.

.. cpp:var:: const std::vector<int> highest_prefactor_orders

    A vector of the highest order of each regulator which appears in the prefactor of the integral.

.. cpp:var:: const std::vector<int> requested_orders

    A vector of the requested orders of each regulator used to generate the C++ library, i.e. the `requested_orders` parameter passed to :func:`~pySecDec.code_writer.make_package` or :func:`~pySecDec.loop_integral.loop_package`.

.. cpp:function:: const std::vector<nested_series_t<sector_container_t>>& get_sectors()

    .. versionchanged:: 1.3.1
        The variable :cpp:var:`sectors` has been replaced by this function.

    A low level interface for obtaining the underlying integrand C++ functions.

    .. warning::

        The precise definition and usage of :cpp:func:`get_sectors` is likely to change in future versions of `pySecDec`.

.. cpp:function:: nested_series_t<integrand_return_t> prefactor(const std::vector<real_t>& real_parameters, const std::vector<complex_t>& complex_parameters)

    The series expansion of the integral prefactor evaluated with the given parameters.
    If the library was generated using :func:`~pySecDec.code_writer.make_package` it will be equal to the `prefactor` passed to :func:`~pySecDec.code_writer.make_package`.
    If the library was generated with :func:`~pySecDec.loop_integral.loop_package` it will be the product of the `additional_prefactor` passed to :func:`~pySecDec.loop_integral.loop_package` and the :math:`\Gamma`-function prefactor of the integral which appears upon Feynman parametrization.

.. cpp:var:: const std::vector<std::vector<real_t>> pole_structures

    A vector of the powers of the monomials that can be factored out of each sector of the polynomial during the decomposition.

    Example: an integral depending on variables :math:`x` and :math:`y` may have two sectors, the first may have a monomial :math:`x^{-1} y^{-2}` factored out and the second may have a monomial :math:`x^{-1}` factored out during the decomposition.
    The resulting `pole_structures` would read ``{ {-1,-2}, {-1,0} }``. Poles of type :math:`x^{-1}` are known as logarithmic poles, poles of type :math:`x^{-2}` are known as linear poles.

.. cpp:function:: std::vector<nested_series_t<integrand_t>> make_integrands(const std::vector<real_t>& real_parameters, const std::vector<complex_t>& complex_parameters)

    `(without contour deformation)`

.. cpp:function:: std::vector<nested_series_t<cuda_integrand_t>> make_cuda_integrands(const std::vector<real_t>& real_parameters, const std::vector<complex_t>& complex_parameters)

    .. versionadded:: 1.4
    `(without contour deformation)` `(CUDA only)`

.. cpp:function:: std::vector<nested_series_t<integrand_t>> make_integrands(const std::vector<real_t>& real_parameters, const std::vector<complex_t>& complex_parameters, unsigned number_of_presamples = 100000, real_t deformation_parameters_maximum = 1., real_t deformation_parameters_minimum = 1.e-5, real_t deformation_parameters_decrease_factor = 0.9)

    `(with contour deformation)`

.. cpp:function:: std::vector<nested_series_t<cuda_integrand_t>> make_cuda_integrands(const std::vector<real_t>& real_parameters, const std::vector<complex_t>& complex_parameters, unsigned number_of_presamples = 100000, real_t deformation_parameters_maximum = 1., real_t deformation_parameters_minimum = 1.e-5, real_t deformation_parameters_decrease_factor = 0.9)

    .. versionadded:: 1.4
    `(with contour deformation)` `(CUDA only)`

    Gives a vector containing the series expansions of individual sectors of the integrand after sector decomposition with the specified `real_parameters` and `complex_parameters` bound.
    Each element of the vector contains the series expansion of an individual sector.
    The series consists of instances of :cpp:type:`integrand_t` (:cpp:type:`cuda_integrand_t`) which contain the integrand functions and the number
    of integration variables upon which they depend.
    The real and complex parameters are bound to the values passed in `real_parameters` and `complex_parameters`.
    If enabled, contour deformation is controlled by the parameters `number_of_presamples`, `deformation_parameters_maximum`, `deformation_parameters_minimum`, `deformation_parameters_decrease_factor`
    which are documented in :class:`pySecDec.integral_interface.IntegralLibrary`. In case of a sign check error (sign_check_error), manually set `number_of_presamples`, `deformation_parameters_maximum`,
    and `deformation_parameters_minimum`.

    Passing the `integrand_t` to the :cpp:func:`secdecutil::Integrator::integrate` function of an instance of a particular :cpp:class:`secdecutil::Integrator` will return the numerically evaluated integral.
    To integrate all orders of all sectors :cpp:func:`secdecutil::deep_apply` can be used.

    .. note::

        This is the recommended way to access the integrand functions.

    .. seealso::

        :ref:`C++ Interface <intlib_cpp>`, :ref:`Integrator Examples<integrator_examples>`, :class:`pySecDec.integral_interface.IntegralLibrary`
